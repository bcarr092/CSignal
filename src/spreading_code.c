/*! \file   spreading_code.c
    \brief  This file contains all the implementation of generating both the
            spreading code and spreading signal (i.e. the c(t) function in SS
            modulation).
 */

#include "spreading_code.h"

/*! \fn     csignal_error_code csignal_get_spreading_code_bit  (
              spreading_code*  in_spreading_code,
              UCHAR*           out_bit
            )
    \brief  Executes one interation of the LFSR in in_spreading_code to generate
            one code bit. A single state change is done by bit-wise anding the
            generator with the state, and summing the result modulo-2 to get the
            next input bit. The output bit is simply the MSB of the state.
 
    \param  in_spreading_code The state and generator of the LFSR
    \param  out_bit The code bit generated by the LFSR
    \return Returns NO_ERROR upon succesful execution or one of these errors
            (see cpc_safe_malloc and csignal_get_spreading_code_bit for other
            possible errors):

            CPC_ERROR_CODE_NULL_POINTER If in_spreading_code or out_bit is NULL
 */
csignal_error_code
csignal_get_spreading_code_bit  (
                                 spreading_code*  in_spreading_code,
                                 UCHAR*           out_bit
                                 );

/*! \fn     UCHAR csignal_sum_ones  (
              UINT32 in_input
            )
    \brief  Sumes the ones in the in_input vector modulo-2
 
    \param  in_input  The vector whose ones are to be summed modulo-2
    \return The count of the number of '1' bits in in_input modulo-2
 */
UCHAR
csignal_sum_ones  (
                   UINT32 in_input
                   );

csignal_error_code
csignal_initialize_spreading_code (
                                   UINT32           in_generator_polynomial,
                                   UINT32           in_initial_state,
                                   spreading_code** out_spreading_code
                                   )
{
  csignal_error_code return_value = CPC_ERROR_CODE_NO_ERROR;
  
  return_value =
    cpc_safe_malloc( ( void** ) out_spreading_code, sizeof( spreading_code ) );
  
  if( CPC_ERROR_CODE_NO_ERROR == return_value )
  {
    if( 0x00000001 & in_generator_polynomial )
    {
      ( *out_spreading_code )->generator_polynomial = in_generator_polynomial;
      ( *out_spreading_code )->state                = in_initial_state;
    }
    else
    {
      CPC_ERROR (
                 "The LSB of the polynomial must be a '1': 0x%x.",
                 in_generator_polynomial
                 );
      
      return_value = CPC_ERROR_CODE_INVALID_PARAMETER;
    }
  }
  else
  {
    CPC_ERROR( "Could not malloc spreading code: 0x%x.", return_value );
  }
  
  return( return_value );
}

csignal_error_code
csignal_get_spreading_code  (
                             spreading_code*  in_spreading_code,
                             UINT32           in_number_of_code_bits,
                             UINT32*          out_size,
                             UCHAR**          out_code
                             )
{
  csignal_error_code return_value = CPC_ERROR_CODE_NO_ERROR;
  
  *out_size = 0;
  *out_code = NULL;
  
  if( NULL == in_spreading_code )
  {
    CPC_LOG_STRING( CPC_LOG_LEVEL_ERROR, "Spreading code is null." );
    
    return_value = CPC_ERROR_CODE_NULL_POINTER;
  }
  else if( 0 == in_number_of_code_bits )
  {
    CPC_LOG_STRING( CPC_LOG_LEVEL_ERROR, "Number of bits is zero." );
    
    return_value = CPC_ERROR_CODE_INVALID_PARAMETER;
  }
  else
  {
    UINT32 byte_index = 0;
    UINT32 bit_index  = 0;
    
    *out_size = in_number_of_code_bits / ( sizeof( UCHAR ) * 8 );
    
    if( 0 != in_number_of_code_bits % 2 )
    {
      *out_size = *out_size + 1;
    }
    
    return_value =
      cpc_safe_malloc (
                       ( void** ) out_code,
                       sizeof( UCHAR ) * *out_size
                      );
    
    if( CPC_ERROR_CODE_NO_ERROR == return_value )
    {
      for( UINT32 i = 0; i < in_number_of_code_bits; i++ )
      {
        UCHAR bit = 0;
        
        return_value =
          csignal_get_spreading_code_bit( in_spreading_code, &bit );
        
        if( CPC_ERROR_CODE_NO_ERROR == return_value )
        {
          CPC_LOG (
                   CPC_LOG_LEVEL_TRACE,
                   "Inserting bit 0x%x at bit index 0x%x of byte 0x%x.",
                   bit,
                   bit_index,
                   byte_index
                   );
          
          CPC_LOG (
                   CPC_LOG_LEVEL_TRACE,
                   "Current byte value before set is 0x%x.",
                   ( *out_code )[ byte_index ]
                   );
          
          ( *out_code )[ byte_index ] |= ( bit << ( 7 - bit_index ) );
          
          CPC_LOG (
                   CPC_LOG_LEVEL_TRACE,
                   "Current byte value before set is 0x%x.",
                   ( *out_code )[ byte_index ]
                   );
          
          bit_index = ( bit_index + 1 ) % 8;
          
          if( 0 == bit_index )
          {
            byte_index++;
          }
        }
        else
        {
          break;
        }
      }
    }
  }
  
  return( return_value );
}

csignal_error_code
csignal_get_spreading_code_bit  (
                                 spreading_code*  in_spreading_code,
                                 UCHAR*           out_bit
                                 )
{
  csignal_error_code return_value = CPC_ERROR_CODE_NO_ERROR;
  
  if( NULL == in_spreading_code || NULL == out_bit )
  {
    CPC_ERROR (
               "Invalid parameters: spreading_code=0x%x, bit=0x%x.",
               in_spreading_code,
               out_bit
               );
    
    return_value = CPC_ERROR_CODE_NULL_POINTER;
  }
  else
  {
    UCHAR new_input =
      csignal_sum_ones  (
                         in_spreading_code->state
                         & in_spreading_code->generator_polynomial
                         );
    
    *out_bit = in_spreading_code->state & 0x00000001;
    
    in_spreading_code->state >>= 1;
    
    if( 0 != new_input )
    {
      in_spreading_code->state  |= 0x80000000;
    }
  }
  
  return( return_value );
}

UCHAR
csignal_sum_ones  (
                   UINT32 in_input
                   )
{
  UCHAR sum = 0;
  
  if( 0 != in_input )
  {
    for( UINT32 i = 0; i < sizeof( UINT32 ) * 8; i++ )
    {
      UINT32 index = ( 0x00000001 << i );
      
      if( index & in_input )
      {
        sum++;
      }
    }
  }
  
  return( ( sum % 2 ) );
}
