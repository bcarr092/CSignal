/*! \file   csignal.h
    \brief  This is the main include file for the csignal library. This is the
            only header file that needs to be included by external libraries/
            binaries.
 
    \note   In this library all signals are stored as FLOAT64 values (double)
            as are all filter values as well as functions performed on signals
            (e.g. FFT). It is the responsibility of the caller to convert the
            signals into the format that they require.
 
    \author Brent Carrara
 */
#ifndef __CSIGNAL_H__
#define __CSIGNAL_H__

#include <cpcommon.h>

#include "wav.h"
#include "spreading_code.h"
#include "gold_code.h"
#include "fir_filter.h"
#include "kaiser_filter.h"
#include "fft.h"
#include "bit_packer.h"
#include "bit_stream.h"

#include "csignal_error_codes.h"

/*! \fn     void csignal_initialize( void )
    \brief  Initializes the csignal library.
 
 */
void
csignal_initialize( void );

/*! \fn     void csignal_terminate( void )
    \brief  Terminates the csignal library.
 
 */
void
csignal_terminate( void );

/*! \fn     csignal_error_code csignal_modulate_symbol (
              UINT32   in_symbol,
              UINT32   in_constellation_size,
              UINT32   in_sample_rate,
              UINT32   in_symbol_duration,
              INT32    in_baseband_pulse_amplitude,
              FLOAT32  in_carrier_frequency,
              FLOAT64* out_signal_inphase,
              FLOAT64* out_signal_quadrature
            )
    \brief  Modulates a data symbol into inphase and quadrature components.
            Let the data symbol value be m, the constellation size be M, the
            sample rate be f_s, each time t_i be a multiple of 1 / f_s, the
            carrier frequency be f_c, and the duration of each symbol (in terms
            of points) be T. This function returns the following:
 
            signal_inphase[ i ] = g( t ) * A_mc * cos( 2 * pi * f_c * t_i )
            signal_outphase[ i ] = g( t ) * A_ms * sin( 2 * pi * f_c * t_i )
 
            where,
      
            A_mc = cos( 2 * pi * m' / M )
            A_ms = sin( 2 * pi * m' / M )
 
            and g( t ) is a rectangular pulse with amplitude 
            in_baseband_pulse_amplitude for each of the T samples. The full
            array signal is returned and is of size T.
 
    \note   The symbol (in_symbol), m, is first converted to a Gray Code, m',
            before it is modulated.
 
    \param  in_symbol The symbol to be modulated, m, it must be < than
                      in_constellation_size
    \param  in_constellation_size The maximum number of possible symbols. Must
                                  be > 0
    \param  in_sample_rate  The rate at which the signal is sampled. Must be >
                            in_sample_rate
    \param  in_symbol_duration  The number of samples in the signal. Must be >
                                0
    \param  in_baseband_pulse_amplitude The shape of the pulse being modulated
    \param  in_carrier_frequency  The frequency of the carrier wave. Must be >
                                  0
    \param  out_signal_inphase  The array of inphase samples returned to the
                                caller if no error is detected.
    \param  out_signal_quadrature The array of quadrature samples returned to
                                  the caller if no error is detected.
    \return Returns NO_ERROR upon succesful exection or one of these errors:
 
            CPC_ERROR_CODE_NULL_POINTER If out_signal_inphase or
                                        out_signal_quadrature are null.
            CPC_ERROR_CODE_INVALID_PARAMETER
              If in_symbol >= in_constellation_size
              If in_carrier_frequency < 0
              If in_sample_rate < 0
 */
csignal_error_code
csignal_modulate_symbol (
                         UINT32   in_symbol,
                         UINT32   in_constellation_size,
                         UINT32   in_sample_rate,
                         USIZE    in_symbol_duration,
                         INT32    in_baseband_pulse_amplitude,
                         FLOAT32  in_carrier_frequency,
                         FLOAT64* out_signal_inphase,
                         FLOAT64* out_signal_quadrature
                         );

/*! \fn     csignal_error_code csignal_spread_signal (
              gold_code* io_gold_code,
              UINT32     in_chip_duration,
              USIZE      in_signal_size,
              INT16*     io_signal
            )
    \brief  This function will spread the signal in io_signal according to the
            spreading code generated by io_gold_code using chips of duration
            in_chip_duration samples.
 
    \param  io_gold_code  The spreading sequence to use
    \param  in_chip_duration  The number of smaples in each chip. Must evenly
                              divide in_signal_size.
    \param  in_signal_size  The number fo samples in io_signal. Must be evenly
                            divisible by in_chip_duration.
    \param  io_signal The signal to spread
    \return Returns NO_ERROR upon succesful exection or one of these errors
            (see cpc_safe_malloc and csignal_get_gold_code for other possible
            errors):
 
            CPC_ERROR_CODE_NULL_POINTER If io_gold_code or io_signal are null
            CPC_ERROR_CODE_INVALID_PARAMETER If in_chip_duration does not evenly
                                             divide in_signal_size or
                                             in_chip_duration is zero.
 */
csignal_error_code
csignal_spread_signal (
                       gold_code* io_gold_code,
                       UINT32     in_chip_duration,
                       USIZE      in_signal_size,
                       FLOAT64*   io_signal
                       );

/*! \def    csignal_error_code csignal_multipliy_signal  (
              USIZE       in_signal_one_length,
              FLOAT64*    in_signal_one,
              USIZE       in_signal_two_length,
              FLOAT64*    in_signal_two,
              USIZE*      out_signal_length,
              FLOAT64**   out_signal
            )
    \brief  Multipy two signals and put the result in a newly created array
            out_signal. out_signal is malloc'd in this function and returned
            to be freed by the caller.
 
    \note   The caller must free out_signal if it is not null.
 
    \param  in_signal_one_length  The number of elements in signal_one.
    \param  in_signal_one The first of two signals to be multiplied.
    \param  in_signal_two_length  The number of elements in signal two.
    \param  in_signal_two The second of two signal to be multiplied.
    \param  out_signal_length The number of elements in out_signal. Should be
                              equal to in_signal_one_length, or zero.
    \param  out_signal A newly created array containing the values of signal_one
                        and signal_two multiplied, or NULL if an error occurrs.
    \return Returns NO_ERROR upon succesful exection or one of these errors
            (see cpc_safe_malloc for other possible errors):
 
            CPC_ERROR_CODE_NULL_POINTER If any of the input parameters are null.
            CPC_ERROR_CODE_INVALID_PARAMETER If the length of signal one and two
                                              are not equal.
 */
csignal_error_code
csignal_multipliy_signal  (
                           USIZE       in_signal_one_length,
                           FLOAT64*    in_signal_one,
                           USIZE       in_signal_two_length,
                           FLOAT64*    in_signal_two,
                           USIZE*      out_signal_length,
                           FLOAT64**   out_signal
                           );

/*! \def    csignal_error_code csignal_calculate_energy  (
              USIZE    in_signal_length,
              FLOAT64* in_signal,
              FLOAT64* out_energy
            )
    \brief  Calculates the signal's energy, E = sum( x[ i ]^2 ).
 
    \param  in_signal_length  The number of elements in in_signal.
    \param  in_signal The signal whose energy is to be calculated.
    \param  out_energy  The energy in in_signal is equal to the sum of elements
                        squared.
    \return Returns NO_ERROR upon succesful exection or one of these errors
            (see cpc_safe_malloc for other possible errors):
 
            CPC_ERROR_CODE_NULL_POINTER If any of the input parameters are null.
 */
csignal_error_code
csignal_calculate_energy  (
                           USIZE    in_signal_length,
                           FLOAT64* in_signal,
                           FLOAT64* out_energy
                           );

#endif  /*  __CSIGNAL_H__ */
